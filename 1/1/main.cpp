#include <iostream>
using namespace std;

int main()
{
    double M = 100000;
    double f[10];
    f[0] = 2 * M;
    f[1] = M;
    for (int i = 2; i <= 6; ++i)
        f[i] = (f[i - 1] / 2) * (f[i - 1] / 2) / M + (1 - f[i - 1] / 2 / M) * f[i - 1];
    
    cout << fixed;
    cout.precision(4);
    for (int i = 1; i <= 6; ++i)
        cout << "f[" << i << "] = " << f[i] << " best bid = " << f[i - 1] / 2 << endl;
    for (int i = 6; i >= 1; --i)
        cout << f[i - 1] / 2 << ", ";
    
    return 0;
}

/*
 1. 考虑左手27张牌，它们的顺序是固定的，但是在最后的54张牌中的位置不固定，共C(54,27)种可能性。选定了左手27张牌的位置后，右手27张牌的位置也就固定了。
 故这样一次洗牌后，扑克牌的顺序有C(54,27)约等于1.95x10^15。
 2. k次洗牌后，总的可能性约为C(54,27)^k，当该数值大于所有扑克牌的顺序54!时，可以认为接近完全随机。
 故 k>=log(54!)/log(C(54,27))约等于4.6，故至少5次洗牌后，扑克牌的顺序接近完全随机。
 */


/*
 动态规划，设M=100000，令f[i]表示花i个月摇到号的最低期望成本，则有
 f[1] = M
 f[i] = min(bid / M * bid + (1 - bid / M) * f[i-1]) (i > 1)
 该转移方程含义为：
 只剩一个月时，必须出全价摇号；
 否则，当出价bid时，有bid/M的可能性直接以bid的价格摇到，还有1-bid/M的可能性需要在接下来的i-1个月继续摇。
 f[i]关于bid是一个二次函数，其最小值在bid=f[i-1]/2时取到，且最小值为f[i] = f[i - 1] - f[i - 1]^2 / 4M
 计算得：
 f[1] = 100000.0000 best bid = 100000.0000
 f[2] = 75000.0000 best bid = 50000.0000
 f[3] = 60937.5000 best bid = 37500.0000
 f[4] = 51654.0527 best bid = 30468.7500
 f[5] = 44983.6998 best bid = 25827.0264
 f[6] = 39924.8667 best bid = 22491.8499
 
 综上：
 从第一个月到第六个月的出价依次为22491.8499, 25827.0264, 30468.7500, 37500.0000, 50000.0000, 100000.0000元。
 最低的期望成本为39924.8667元。
 */
